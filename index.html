<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>森林裡的99夜 (3D多人版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        #instructions {
            width: 100%;
            max-width: 500px;
            text-align: center;
            color: white;
            padding: 20px;
        }
        #instructions h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        #instructions p {
             font-size: 1.1rem;
             line-height: 1.6;
        }
        #instructions .controls {
            margin-top: 1.5rem;
            background: rgba(255,255,255,0.1);
            padding: 1rem;
            border-radius: 10px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            pointer-events: none;
        }
        .hud .stat-bar {
            width: 100%;
            background-color: rgba(255,255,255,0.2);
            border-radius: 5px;
            height: 20px;
            margin-top: 5px;
            overflow: hidden;
        }
        .hud .stat-bar > div {
            height: 100%;
            transition: width 0.3s ease;
            text-align: center;
            font-size: 12px;
            line-height: 20px;
        }
        #interaction-prompt {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 5px;
            display: none; /* Initially hidden */
            pointer-events: none;
        }
        #player-id-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1 class="text-emerald-400">森林裡的99夜</h1>
            <p>點擊螢幕開始遊戲</p>
            <div class="controls">
                <p><strong>移動:</strong> W, A, S, D</p>
                <p><strong>跳躍:</strong> 空白鍵</p>
                <p><strong>環顧四周:</strong> 滑鼠</p>
                <p><strong>互動/收集:</strong> 左鍵點擊</p>
            </div>
             <p id="loading-text" class="mt-4 text-amber-300">正在連接伺服器並生成森林...</p>
        </div>
    </div>

    <div id="crosshair"></div>
    
    <div class="hud">
        <h2 id="day-counter" class="text-2xl font-bold text-amber-300">第 1 天</h2>
        <div class="mt-2">
            <strong>健康</strong>
            <div class="stat-bar"><div id="health-bar" class="bg-red-500" style="width: 100%;">100%</div></div>
        </div>
        <div class="mt-2">
            <strong>飢餓</strong>
            <div class="stat-bar"><div id="hunger-bar" class="bg-orange-500" style="width: 100%;">100%</div></div>
        </div>
        <div class="mt-4">
            <h3 class="font-bold">資源:</h3>
            <p>木材: <span id="wood-count">0</span></p>
            <p>石塊: <span id="stone-count">0</span></p>
            <p>食物: <span id="food-count">2</span></p>
        </div>
    </div>
    
    <div id="interaction-prompt"></div>
    <div id="player-id-display">您的ID: <span id="user-id"></span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInAnonymously, signInWithCustomToken } from 'firebase/auth';
        import { getFirestore, collection, doc, onSnapshot, setDoc, deleteDoc, addDoc } from 'firebase/firestore';

        // --- Global variables ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime;
        
        const objects = []; 
        const interactableObjects = [];
        let worldObjects = new Map(); // Store world objects by their unique ID
        const raycaster = new THREE.Raycaster();

        // --- Multiplayer variables ---
        let db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const remotePlayers = new Map();
        let playersCollection, destroyedObjectsCollection;
        let lastPositionUpdateTime = 0;

        // --- Game State ---
        let gameState = {
            day: 1,
            health: 100,
            hunger: 100,
            resources: { wood: 0, stone: 0, food: 2 },
            timeOfDay: 0.25,
            dayDuration: 240
        };

        // --- UI Elements ---
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const loadingText = document.getElementById('loading-text');

        // --- Seeded RNG for consistent world generation ---
        let seed = 1;
        function seededRandom() {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }
        
        async function init() {
            await initFirebase();
            initScene();
            createWorld();
            setupEventListeners();
            updateUI();
            
            prevTime = performance.now();
            animate();
        }

        async function initFirebase() {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                userId = auth.currentUser.uid;
                document.getElementById('user-id').textContent = userId;

                // Set collection paths
                playersCollection = collection(db, `artifacts/${appId}/public/data/players`);
                destroyedObjectsCollection = collection(db, `artifacts/${appId}/public/data/destroyed_objects`);

                setupFirestoreListeners();
            } catch (error) {
                console.error("Firebase Authentication Error:", error);
                loadingText.textContent = "無法連接到伺服器。請刷新頁面重試。";
            }
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 10;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(50, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 180;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.camera.left = -120;
            dirLight.shadow.camera.right = 120;
            scene.add(dirLight);
            scene.userData.dirLight = dirLight;
            scene.userData.ambientLight = ambientLight;

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
        }
        
        function setupEventListeners() {
             instructions.addEventListener('click', () => controls.lock());
             controls.addEventListener('lock', () => { instructions.style.display = 'none'; });
             controls.addEventListener('unlock', () => { instructions.style.display = 'flex'; });

             const onKeyDown = (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump) velocity.y += 350; canJump = false; break;
                }
            };
            const onKeyUp = (event) => {
                 switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('beforeunload', async () => {
                if (userId) await deleteDoc(doc(playersCollection, userId));
            });
        }

        function setupFirestoreListeners() {
            // Listen for other players
            onSnapshot(playersCollection, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const playerData = change.doc.data();
                    const playerId = change.doc.id;

                    if (playerId === userId) return; // Ignore self

                    if (change.type === "added" || change.type === "modified") {
                        if (!remotePlayers.has(playerId)) {
                            // Create new player mesh
                            const playerGeo = new THREE.CapsuleGeometry(1, 1.5, 4, 8);
                            const playerMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                            const playerMesh = new THREE.Mesh(playerGeo, playerMat);
                            playerMesh.castShadow = true;
                            scene.add(playerMesh);
                            remotePlayers.set(playerId, { mesh: playerMesh, data: playerData });
                        }
                        // Update player position and rotation (interpolation can be added here)
                        const remotePlayer = remotePlayers.get(playerId);
                        remotePlayer.data = playerData; // Store latest data for animation loop
                    } else if (change.type === "removed") {
                        if (remotePlayers.has(playerId)) {
                            const playerToRemove = remotePlayers.get(playerId);
                            scene.remove(playerToRemove.mesh);
                            remotePlayers.delete(playerId);
                        }
                    }
                });
            });

            // Listen for destroyed world objects
            onSnapshot(destroyedObjectsCollection, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const objectId = change.doc.id;
                        if (worldObjects.has(objectId)) {
                            const objToRemove = worldObjects.get(objectId);
                            scene.remove(objToRemove.main);
                            if(objToRemove.secondary) scene.remove(objToRemove.secondary);
                            
                            const interactableIdx = interactableObjects.findIndex(o => o.userData.id === objectId);
                            if(interactableIdx > -1) interactableObjects.splice(interactableIdx, 1);

                            worldObjects.delete(objectId);
                        }
                    }
                });
            });
        }

        function createWorld() {
            seed = appId.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0);
            
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            for (let i = 0; i < 200; i++) createTree(seededRandom() * 800 - 400, seededRandom() * 800 - 400);
            for (let i = 0; i < 50; i++) createRock(seededRandom() * 800 - 400, seededRandom() * 800 - 400);
            for (let i = 0; i < 70; i++) createBush(seededRandom() * 800 - 400, seededRandom() * 800 - 400);

            loadingText.style.display = 'none';
        }
        
        function createObject(id, mainMesh, secondaryMesh = null) {
            mainMesh.userData.id = id;
            scene.add(mainMesh);
            if (secondaryMesh) scene.add(secondaryMesh);
            worldObjects.set(id, { main: mainMesh, secondary: secondaryMesh });
            if (mainMesh.userData.type) {
                interactableObjects.push(mainMesh);
            }
        }
        
        function createTree(x, z) {
            const id = `tree_${Math.round(x)}_${Math.round(z)}`;
            if (worldObjects.has(id)) return;
            const trunkHeight = seededRandom() * 10 + 10;
            const trunkGeo = new THREE.CylinderGeometry(0.5, 1, trunkHeight, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.userData = { type: 'wood', health: 3 };
            
            const leavesHeight = seededRandom() * 5 + 5;
            const leavesGeo = new THREE.ConeGeometry(5, leavesHeight, 8);
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x006400 });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.set(x, trunkHeight + leavesHeight / 2, z);
            leaves.castShadow = true;
            leaves.receiveShadow = true;

            createObject(id, trunk, leaves);
        }
        
        function createRock(x, z) {
            const id = `rock_${Math.round(x)}_${Math.round(z)}`;
            if (worldObjects.has(id)) return;
            const size = seededRandom() * 2 + 1;
            const rockGeo = new THREE.IcosahedronGeometry(size, 0);
            const rockMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, size/2, z);
            rock.castShadow = true;
            rock.userData = { type: 'stone', health: 2 };
            createObject(id, rock);
        }
        
        function createBush(x, z) {
            const id = `bush_${Math.round(x)}_${Math.round(z)}`;
            if (worldObjects.has(id)) return;
            const size = seededRandom() * 1.5 + 0.5;
            const bushGeo = new THREE.SphereGeometry(size, 8, 6);
            const bushMat = new THREE.MeshLambertMaterial({ color: 0x556B2F });
            const bush = new THREE.Mesh(bushGeo, bushMat);
            bush.position.set(x, size/2, z);
            bush.castShadow = true;
            bush.userData = { type: 'food', health: 1 };
            createObject(id, bush);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            updateGameState(delta);
            updatePlayerMovement(delta);
            updateRemotePlayers(delta);
            updateInteractionPrompt();
            
            if (time > lastPositionUpdateTime + 100) { // Update position 10 times per second
                updatePlayerPositionOnFirestore();
                lastPositionUpdateTime = time;
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
        
        function updatePlayerMovement(delta) {
             if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 5) {
                    velocity.y = 0;
                    controls.getObject().position.y = 5;
                    canJump = true;
                }
            }
        }
        
        function updateRemotePlayers(delta) {
            remotePlayers.forEach(player => {
                // Smoothly interpolate position
                player.mesh.position.lerp(new THREE.Vector3(player.data.position.x, player.data.position.y, player.data.position.z), 0.2);
                
                // Smoothly interpolate rotation
                const targetQuat = new THREE.Quaternion(player.data.quaternion._x, player.data.quaternion._y, player.data.quaternion._z, player.data.quaternion._w);
                player.mesh.quaternion.slerp(targetQuat, 0.2);
            });
        }
        
        async function updatePlayerPositionOnFirestore() {
            if (userId && controls.isLocked) {
                const playerDocRef = doc(playersCollection, userId);
                const position = controls.getObject().position;
                const quaternion = camera.quaternion;
                await setDoc(playerDocRef, { position: { ...position }, quaternion: { ...quaternion } });
            }
        }

        function updateGameState(delta) {
             gameState.timeOfDay += delta / gameState.dayDuration;
             if (gameState.timeOfDay >= 1) {
                 gameState.timeOfDay = 0;
                 gameState.day++;
             }
             
             const sunAngle = gameState.timeOfDay * Math.PI * 2;
             const dirLight = scene.userData.dirLight;
             const ambientLight = scene.userData.ambientLight;
             
             dirLight.position.x = 200 * Math.cos(sunAngle);
             dirLight.position.y = 200 * Math.sin(sunAngle);
             
             if (Math.sin(sunAngle) < -0.1) {
                dirLight.intensity = 0.05;
                ambientLight.intensity = 0.1;
                scene.background.setHex(0x000033);
                scene.fog.color.setHex(0x000033);
             } else { 
                const intensity = Math.max(0.1, Math.sin(sunAngle));
                dirLight.intensity = 1.5 * intensity;
                ambientLight.intensity = 0.5 * intensity + 0.2;
                scene.background.lerpColors(new THREE.Color(0x000033), new THREE.Color(0x87ceeb), intensity);
                scene.fog.color.lerpColors(new THREE.Color(0x000033), new THREE.Color(0x87ceeb), intensity);
             }
             
             gameState.hunger -= delta * 0.5;
             if (gameState.hunger <= 0) {
                 gameState.hunger = 0;
                 gameState.health -= delta * 1;
             }
             
             if (gameState.health <= 0) {
                 controls.unlock();
                 blocker.style.display = 'flex';
                 instructions.innerHTML = `<h1>遊戲結束</h1><p>你在第 ${gameState.day} 天倒下了。</p><p class="mt-4 text-xl">點擊以重新開始</p>`;
                 instructions.addEventListener('click', () => window.location.reload(), { once: true });
             }

             if (gameState.day > 99) {
                controls.unlock();
                blocker.style.display = 'flex';
                instructions.innerHTML = `<h1>恭喜你！</h1><p>你成功存活了99夜！</p><p class="mt-4 text-xl">點擊以重新開始</p>`;
                instructions.addEventListener('click', () => window.location.reload(), { once: true });
             }
             
             updateUI();
        }

        function updateUI() {
            document.getElementById('day-counter').innerText = `第 ${gameState.day} 天`;
            document.getElementById('health-bar').style.width = gameState.health + '%';
            document.getElementById('health-bar').innerText = Math.round(gameState.health) + '%';
            document.getElementById('hunger-bar').style.width = gameState.hunger + '%';
            document.getElementById('hunger-bar').innerText = Math.round(gameState.hunger) + '%';
            document.getElementById('wood-count').innerText = gameState.resources.wood;
            document.getElementById('stone-count').innerText = gameState.resources.stone;
            document.getElementById('food-count').innerText = gameState.resources.food;
        }
        
        function updateInteractionPrompt() {
            if (!controls.isLocked) return;

            raycaster.setFromCamera({x:0, y:0}, camera);
            const intersects = raycaster.intersectObjects(interactableObjects);
            const prompt = document.getElementById('interaction-prompt');

            if (intersects.length > 0 && intersects[0].distance < 10) {
                const object = intersects[0].object;
                const type = object.userData.type;
                let text = '';
                if (type === 'wood') text = '砍伐樹木';
                if (type === 'stone') text = '開採石頭';
                if (type === 'food') text = '採集食物';
                
                prompt.textContent = `[點擊] ${text}`;
                prompt.style.display = 'block';
            } else {
                prompt.style.display = 'none';
            }
        }
        
        async function onMouseClick() {
            if (!controls.isLocked) return;

            raycaster.setFromCamera({x:0, y:0}, camera);
            const intersects = raycaster.intersectObjects(interactableObjects);

            if (intersects.length > 0 && intersects[0].distance < 10) {
                const object = intersects[0].object;
                object.userData.health--;
                
                // Visual feedback (e.g., object shakes) could be added here
                
                if (object.userData.health <= 0) {
                    const type = object.userData.type;
                    if (type === 'wood') gameState.resources.wood += 5;
                    if (type === 'stone') gameState.resources.stone += 2;
                    if (type === 'food') gameState.resources.food += 1;
                    
                    // Instead of removing locally, we register the destruction on Firestore
                    const objectId = object.userData.id;
                    await setDoc(doc(destroyedObjectsCollection, objectId), { destroyedAt: Date.now() });
                }
                updateUI();
            }
        }
        
        init();

    </script>
</body>
</html>

